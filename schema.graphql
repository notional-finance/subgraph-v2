enum AssetType {
  Underlying,
  nToken,
  WrappedfCash,
  PrimeCash,
  PrimeDebt,
  fCash,
  VaultShare,
  VaultDebt,
  VaultCash,
  NOTE
}

enum SystemAccount {
  None,
  ZeroAddress,
  FeeReserve,
  SettlementReserve,
  Vault,
  nToken,
  PrimeCash,
  PrimeDebt,
  Notional,
  NOTE
}

enum AssetInterface {
  ERC20,
  ERC1155
}

enum TransferType {
  Mint,
  Burn,
  Transfer
}

type Asset @entity {
  """ID space varies by asset type:
    - Proxy ERC20 interfaces have the address as the id
    - ERC1155 assets have the uint256 identifier as the id
    - Underlying Currencies have the uin16 currency id as the id
  """
  id: ID!

  firstUpdateBlockNumber: Int!
  firstUpdateTimestamp: Int!
  firstUpdateTransactionHash: Bytes!

  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  assetType: AssetType!
  assetInterface: AssetInterface!
  "A link to the underlying asset if this asset is not underlying itself"
  underlying: Asset
  
  name: String!
  symbol: String!
  totalSupply: BigInt!
  precision: BigInt!
  "Set to true for underlying tokens that have a transfer fee"
  hasTransferFee: Boolean!

  isfCashDebt: Boolean!
  "Maturities are only set for some asset types"
  maturity: Int
  "Vault address is set for vault asset types"
  vaultAddress: Bytes

  "Set to the ERC20 address or Notional Proxy for ERC1155 addresses"
  tokenAddress: Bytes!

  balanceOf: [Balance!] @derivedFrom(field: "asset")
  transfers: [Transfer!] @derivedFrom(field: "asset")
  oracles: [Oracle!] @derivedFrom(field: "quote")
}

type Balance @entity {
  "Address of Account:ID of Asset"
  id: ID!
  "Link back to the asset"
  asset: Asset!
  "Address of the account that holds this balance"
  account: Account!

  firstUpdateBlockNumber: Int!
  firstUpdateTimestamp: Int!
  firstUpdateTransactionHash: Bytes!

  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  
  balance: BigInt!
}

type Transfer @entity {
  "Transaction Hash:Log Index"
  id: ID!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Transaction!
  logIndex: Int!

  from: Account!
  to: Account!
  "Operator is logged for ERC1155 transfer events"
  operator: Account
  "Categorizes the transfer as a mint, burn or transfer"
  transferType: TransferType!
  fromSystemAccount: SystemAccount!
  toSystemAccount: SystemAccount!

  value: BigInt!
  "Value of the transfer in underlying terms at the time of transfer"
  valueInUnderlying: BigInt

  "Link to the asset entity for this transfer"
  asset: Asset!
  assetType: AssetType!
  underlying: Asset!
  "Only set for some transfer types"
  maturity: Int

  "Link to the transfer bundle this sits in"
  bundle: TransferBundle

  "Link to the transaction type this sits in"
  transactionType: TransactionType
}

type TransferBundle @entity {
  "Transaction Hash:Start Log Index:End Log Index:Bundle Name"
  id: ID!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Transaction!

  bundleName: String!
  transfers: [Transfer!] @derivedFrom(field: "bundle")
  
  "A logical grouping of transfer bundles into transaction types"
  transactionType: TransactionType
}

type TransactionType @entity {
  "Transaction Hash:Start Log Index:End Log Index:Transaction Type"
  id: ID!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Transaction!

  # TODO: this needs to have arbitrary properties
}

type Transaction @entity {
  "Transaction Hash"
  id: ID!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!

  _transfers: [Transfer!]
  _transferBundles: [TransferBundle!]
  _transactionTypes: [TransactionType!]
  "Internal index of the last transfer that was bundled"
  _lastBundledTransfer: Int!

  transfers: [Transfer!] @derivedFrom(field: "transactionHash")
  transferBundles: [TransferBundle!] @derivedFrom(field: "transactionHash")
  transactionTypes: [TransactionType!] @derivedFrom(field: "transactionHash")
}

type Account @entity {
  "Address of Account"
  id: ID!

  firstUpdateBlockNumber: Int!
  firstUpdateTimestamp: Int!
  firstUpdateTransactionHash: Bytes!

  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  systemAccountType: SystemAccount!

  "All current balances linked to this account"
  balances: [Balance!] @derivedFrom(field: "account")
  "All historical asset transfers linked to this account"
  transfersFrom: [Transfer!] @derivedFrom(field: "from")
  transfersTo: [Transfer!] @derivedFrom(field: "to")
}

# Exchange Rates
enum OracleType {
  Chainlink,
  fCashOracleRate,
  fCashSpotRate,
  fCashSettlementRate,
  PrimeCashToUnderlyingOracleSupplyRate,
  PrimeCashToMoneyMarketOracleSupplyRate,
  PrimeCashToUnderlyingSpotRate,
  PrimeCashToMoneyMarketSpotRate,
  PrimeDebtToUnderlyingSpotRate,
  PrimeDebtToMoneyMarketSpotRate,
  VaultShareOracleRate,
}

type OracleRegistry @entity {
  "ID is hardcoded to zero"
  id: ID!
  "All oracles, required for block update handler"
  oracles: [Oracle!]
}

type Oracle @entity {
  "Base Currency Id:Quote Currency Id"
  id: ID!

  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  base: Asset!
  quote: Asset!
  ratePrecision: BigInt!
  latestRate: BigInt!
  oracleAddress: Bytes!
  oracleType: OracleType!

  historicalRates: [ExchangeRate!] @derivedFrom(field: "oracle")
}

type ExchangeRate @entity {
  "External Oracle ID:Block Number"
  id: ID!
  blockNumber: Int!
  timestamp: Int!
  rate: BigInt!

  oracle: Oracle!
}

# Configuration