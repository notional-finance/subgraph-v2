enum AssetType {
  Underlying,
  nToken,
  WrappedfCash,
  PrimeCash,
  PrimeDebt,
  fCash,
  VaultShare,
  VaultDebt,
  VaultCash,
  NOTE
}

enum SystemAccount {
  None,
  ZeroAddress,
  FeeReserve,
  SettlementReserve,
  Vault,
  nToken,
  PrimeCash,
  PrimeDebt,
  Notional,
  NOTE
}

enum AssetInterface {
  ERC20,
  ERC1155
}

enum TransferType {
  Mint,
  Burn,
  Transfer
}

type Asset @entity {
  """ID space varies by asset type:
    - Proxy ERC20 interfaces have the address as the id
    - ERC1155 assets have the uint256 identifier as the id
    - Underlying Currencies have the uin16 currency id as the id
  """
  id: ID!

  firstUpdateBlockNumber: Int!
  firstUpdateTimestamp: Int!
  firstUpdateTransactionHash: Bytes

  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes

  assetType: AssetType!
  assetInterface: AssetInterface!
  "A link to the underlying asset if this asset is not underlying itself"
  underlying: Asset
  
  name: String!
  symbol: String!
  totalSupply: BigInt!
  precision: BigInt!
  "Set to true for underlying tokens that have a transfer fee"
  hasTransferFee: Boolean!

  isfCashDebt: Boolean!
  "Maturities are only set for some asset types"
  maturity: Int
  "Vault address is set for vault asset types"
  vaultAddress: Bytes

  "Set to the ERC20 address or Notional Proxy for ERC1155 addresses"
  tokenAddress: Bytes!

  balanceOf: [Balance!] @derivedFrom(field: "asset")
  transfers: [Transfer!] @derivedFrom(field: "asset")
  oracles: [Oracle!] @derivedFrom(field: "quote")
}

type Transfer @entity {
  "Transaction Hash:Log Index"
  id: ID!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Transaction!
  logIndex: Int!

  from: Account!
  to: Account!
  "Operator is logged for ERC1155 transfer events"
  operator: Account
  "Categorizes the transfer as a mint, burn or transfer"
  transferType: TransferType!
  fromSystemAccount: SystemAccount!
  toSystemAccount: SystemAccount!

  value: BigInt!
  "Value of the transfer in underlying terms at the time of transfer"
  valueInUnderlying: BigInt

  "Link to the asset entity for this transfer"
  asset: Asset!
  assetType: AssetType!
  underlying: Asset!
  "Only set for some transfer types"
  maturity: Int

  "Link to the transfer bundle this sits in"
  bundle: TransferBundle
}

type TransferBundle @entity {
  "Transaction Hash:Start Log Index:End Log Index:Bundle Name"
  id: ID!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Transaction!

  bundleName: String!
  transfers: [Transfer!] @derivedFrom(field: "bundle")
}

type Transaction @entity {
  "Transaction Hash"
  id: ID!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!

  _transfers: [Transfer!]
  _transferBundles: [TransferBundle!]
  "Internal index of the last transfer that was bundled"
  _lastBundledTransfer: Int!

  transfers: [Transfer!] @derivedFrom(field: "transactionHash")
  transferBundles: [TransferBundle!] @derivedFrom(field: "transactionHash")
}

type Account @entity {
  "Address of Account"
  id: ID!

  firstUpdateBlockNumber: Int!
  firstUpdateTimestamp: Int!
  firstUpdateTransactionHash: Bytes!

  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  systemAccountType: SystemAccount!

  "All current balances linked to this account"
  balances: [Balance!] @derivedFrom(field: "account")
  "All historical asset transfers linked to this account"
  transfersFrom: [Transfer!] @derivedFrom(field: "from")
  transfersTo: [Transfer!] @derivedFrom(field: "to")
}

### Exchange Rates ###

enum OracleType {
  Chainlink,
  fCashOracleRate,
  fCashSettlementRate,
  PrimeCashToMoneyMarketOracleInterestRate,
  MoneyMarketToUnderlyingOracleInterestRate,
  PrimeCashToUnderlyingExchangeRate,
  PrimeCashToMoneyMarketExchangeRate,
  PrimeDebtToUnderlyingExchangeRate,
  PrimeDebtToMoneyMarketExchangeRate,
  MoneyMarketToUnderlyingExchangeRate
  VaultShareOracleRate,
}

type OracleRegistry @entity {
  "ID is hardcoded to zero"
  id: ID!
  lastRefreshBlockNumber: Int!
  lastRefreshTimestamp: Int!

  chainlinkOracles: [Oracle!]!
  "Underlying assets that have fCash listed"
  fCashEnabled: [Asset!]!
  "Vault Addresses"
  listedVaults: [Bytes!]!
}

type Oracle @entity {
  "Base Asset Id:Quote Asset Id:Oracle Type"
  id: ID!

  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  "Some oracles are updated via block handlers and do not have a txn hash for updates"
  lastUpdateTransactionHash: Bytes

  base: Asset!
  quote: Asset!
  ratePrecision: BigInt!
  oracleAddress: Bytes!
  oracleType: OracleType!
  mustInvert: Boolean!
  latestRate: BigInt

  historicalRates: [ExchangeRate!] @derivedFrom(field: "oracle")
}

type ExchangeRate @entity {
  "External Oracle ID:Block Number:Transaction Index"
  id: ID!
  blockNumber: Int!
  timestamp: Int!
  rate: BigInt!

  oracle: Oracle!
}

### Configuration ###

type CurrencyConfiguration @entity {
  "Currency ID"
  id: ID!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  underlying: Asset
  pCash: Asset
  "Some currencies will not allow prime debt"
  pDebt: Asset

  maxUnderlyingSupply: BigInt

  "Exchange Rate Parameters"
  collateralHaircut: Int
  debtBuffer: Int
  liquidationDiscount: Int

  "Prime Cash Parameters"
  primeCashRateOracleTimeWindowSeconds: Int
  primeCashHoldingsOracle: Bytes
  primeCashCurve: InterestRateCurve
  primeDebtAllowed: Boolean

  "Time window in seconds that the rate oracle will be averaged over"
  fCashRateOracleTimeWindowSeconds: Int
  "Share of the fees given to the protocol, denominated in percentage"
  fCashReserveFeeSharePercent: Int
  "Debt buffer specified in basis points"
  fCashDebtBufferBasisPoints: Int
  "fCash haircut specified in basis points"
  fCashHaircutBasisPoints: Int
  "Discount on fCash given to the liquidator in basis points"
  fCashLiquidationHaircutBasisPoints: Int
  "Discount on negative fCash given to the liquidator in basis points"
  fCashLiquidationDebtBufferBasisPoints: Int
  "Current set of interest rate curves for the fCash markets"
  fCashActiveCurves: [InterestRateCurve!]
  "Next set of interest rate curves for the fCash markets"
  fCashNextCurves: [InterestRateCurve!]

  "The minimum threshold of the reserve before they can be harvested"
  treasuryReserveBuffer: BigInt
  
  "Addresses of potential prime cash holdings"
  primeCashHoldings: [Bytes!]
  "Rebalancing targets"
  rebalancingTargets: [Int!]
  "Rebalancing cooldown"
  rebalancingCooldown: Int

  "Proportion of deposits that go into each corresponding market"
  depositShares: [Int!]
  "Maximum market proportion that the nToken will provide liquidity at"
  leverageThresholds: [Int!]
  "Market proportions used during market initialization"
  proportions: [Int!]
  deprecated_anchorRates: [Int!]

  "Annual incentive emission rate"
  incentiveEmissionRate: BigInt
  secondaryIncentiveRewarder: Bytes

  "Residual purchase incentive in basis points"
  residualPurchaseIncentiveBasisPoints: Int
  "Seconds until residuals become available to purchase after market initialization"
  residualPurchaseTimeBufferSeconds: Int
  "Basis points of cash withholding for negative fCash"
  cashWithholdingBufferBasisPoints: Int
  "Percentage of the nToken PV that is used during free collateral"
  pvHaircutPercentage: Int
  "Discount on nToken PV given to liquidators"
  liquidationHaircutPercentage: Int
}

type InterestRateCurve @entity {
  "ID is the currency id:market index:true if current"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  kinkUtilization1: Int!
  kinkUtilization2: Int!
  kinkRate1: Int!
  kinkRate2: Int!
  maxRate: Int!
  minFeeRate: Int!
  maxFeeRate: Int!
  feeRatePercent: Int!
}

type VaultConfiguration @entity {
  "ID is the address of the vault"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  "Address of the strategy vault"
  vaultAddress: Bytes!
  "Strategy identifier for the vault"
  strategy: Bytes!
  "Name of the strategy vault"
  name: String!
  "Primary currency the vault borrows in"
  primaryBorrowCurrency: Asset!
  "Minimum amount of primary currency that must be borrowed"
  minAccountBorrowSize: BigInt!
  "Minimum collateral ratio before liquidation"
  minCollateralRatioBasisPoints: Int!
  "Maximum collateral ratio that liquidation can reach"
  maxDeleverageCollateralRatioBasisPoints: Int!
  "Fee assessed on primary borrow paid to the nToken and protocol"
  feeRateBasisPoints: Int!
  "Share of fee paid to protocol reserve"
  reserveFeeSharePercent: Int!
  "Discount rate given to liquidators"
  liquidationRatePercent: Int!
  "Maximum market index for borrowing terms"
  maxBorrowMarketIndex: Int!
  "Secondary borrow currencies (if any)"
  secondaryBorrowCurrencies: [Asset!]
  "Max required collateral ratio for vault accounts"
  maxRequiredAccountCollateralRatioBasisPoints: Int
  "Can the vault be entered"
  enabled: Boolean!
  "Allows positions to be rolled forward"
  allowRollPosition: Boolean!
  "Only the vault can enter"
  onlyVaultEntry: Boolean!
  "Only the vault can exit"
  onlyVaultExit: Boolean!
  "Only the vault can roll"
  onlyVaultRoll: Boolean!
  "Only the vault can liquidate"
  onlyVaultDeleverage: Boolean!
  "Only the vault can settle"
  onlyVaultSettle: Boolean!
  "Vault is allowed to re-enter Notional"
  allowsReentrancy: Boolean!
  "Deleveraging is disabled on this vault"
  deleverageDisabled: Boolean

  maxPrimaryBorrowCapacity: BigInt!
  totalUsedPrimaryBorrowCapacity: BigInt!

  maxSecondaryBorrowCapacity: [BigInt!]
  totalUsedSecondaryBorrowCapacity: [BigInt!]
  minAccountSecondaryBorrow: [BigInt!]
}
  # TODO: all of this information should sit on the account and total supply entities
  "All maturities of this strategy vault"
  # maturities: [LeveragedVaultMaturity!] @derivedFrom(field: "leveragedVault")

enum WhitelistedCapability {
  GlobalTransferOperator,
  AuthorizedCallbackContract
}

type WhitelistedContract @entity {
  id: ID!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  capability: [WhitelistedCapability!]!
}

### Balances ###

type Balance @entity {
  "Address of Account:ID of Asset"
  id: ID!
  "Link back to the asset"
  asset: Asset!
  "Address of the account that holds this balance"
  account: Account!

  firstUpdateBlockNumber: Int!
  firstUpdateTimestamp: Int!
  firstUpdateTransactionHash: Bytes!

  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  
  balance: BigInt!
}

### Markets ###

type ActiveMarkets @entity {
  "Currency ID"
  id: ID!
  underlying: Asset!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  
  markets: [Market!]!
}

type Market @entity {
  "Currency Id:Settlement Date:Maturity combination"
  id: ID!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  "Currency of this market"
  underlying: Asset!
  "Date that fCash from this market will mature"
  maturity: Int!
  "Date that this market will settle"
  settlementDate: Int!
  "Market index"
  marketIndex: Int!
  "Length of market maturity in seconds"
  marketMaturityLengthSeconds: Int!

  current: MarketSnapshot!
  snapshots: [MarketSnapshot!] @derivedFrom(field: "market")
}

type MarketSnapshot @entity {
  "Market ID:Transaction Hash"
  id: ID!
  market: Market!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!

  "Total fCash available in the market"
  totalfCash: BigInt!
  "Total asset cash available in the market"
  totalPrimeCash: BigInt!
  "Total liquidity tokens available in the market"
  totalLiquidity: BigInt!
  "Last annualized interest rate the market traded at"
  lastImpliedRate: Int!
  "Oracle rate for the market, must be averaged in using previousTradeTime"
  oracleRate: Int!
  "Last time when a trade occurred on the market"
  previousTradeTime: Int!
}

### Treasury ###

type Incentives @entity {
  "ID is the currency id"
  id: ID!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  currencyConfiguration: CurrencyConfiguration!

  "Current accumulated NOTE per nToken"
  accumulatedNOTEPerNToken: BigInt

  "Deprecated last supply change time value"
  deprecated_lastSupplyChangeTime: BigInt
  "Deprecated integral total supply value"
  deprecated_integralTotalSupply: BigInt
  "Snapshot of the incentive emission rate at migration"
  migrationEmissionRate: BigInt
  "Snapshot of the integral total supply at migration"
  finalIntegralTotalSupply: BigInt
  "Time when the currency was migrated"
  migrationTime: BigInt
}

# Staked NOTE
# Vault Reinvestments?