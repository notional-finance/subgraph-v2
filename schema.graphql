enum AssetType {
  nToken,
  WrappedfCash,
  PrimeCash,
  PrimeDebt,
  PositivefCash,
  NegativefCash,
  VaultShare,
  VaultDebt,
  VaultCash
}

enum AssetInterface {
  ERC20,
  ERC1155
}

enum TransferType {
  Mint,
  Burn,
  Transfer
}

type Underlying @entity {
  "ID is equal to the currency ID on Notional"
  id: ID!
  firstUpdateBlockNumber: Int!
  firstUpdateTimestamp: Int!
  firstUpdateTransactionHash: Int!

  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  name: String!
  symbol: String!
  decimals: Int!
  tokenAddress: Bytes!
  hasTransferFee: Boolean!

  assets: [Asset!] @derivedFrom(field: "underlying")
}

type Asset @entity {
  "ERC20 interfaces have the address as the id, ERC1155 use the uint256 id"
  id: ID!

  firstUpdateBlockNumber: Int!
  firstUpdateTimestamp: Int!
  firstUpdateTransactionHash: Int!

  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  assetType: AssetType!
  assetInterface: AssetInterface!
  
  name: String!
  symbol: String!
  underlying: Underlying!
  totalSupply: BigInt!
  decimals: Int!

  balanceOf: [Balance!] @derivedFrom(field: "asset")
  transfers: [Transfer!] @derivedFrom(field: "asset")

  "Maturities are only set for some asset types"
  maturity: Int
  "Set to the ERC20 address or Notional Proxy for ERC1155 addresses"
  assetAddress: Bytes!
}

type Balance @entity {
  "Address of Account:ID of Asset"
  id: ID!
  "Link back to the asset"
  asset: Asset!
  "Address of the account that holds this balance"
  account: Account!

  firstUpdateBlockNumber: Int!
  firstUpdateTimestamp: Int!
  firstUpdateTransactionHash: Int!

  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  
  balance: BigInt!
}

type Transfer @entity {
  "Transaction Hash:Log Index"
  id: ID!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Transaction!
  logIndex: Int!

  from: Account!
  to: Account!
  value: BigInt!

  "Value of the transfer in underlying terms at the time of transfer"
  valueInUnderlying: BigInt

  "Link to the asset entity for this transfer"
  asset: Asset!
  "Type of asset that is transferred"
  assetType: AssetType!
  "Interface for the asset transfer"
  assetInterface: AssetInterface!
  "Categorizes the transfer as a mint, burn or transfer"
  transferType: TransferType!
  "Link to the underlying currency this asset is denominated in"
  underlying: Underlying!

  "Optional field when the asset has a maturity (ERC1155 only)"
  maturity: Int
  "Optional field when the asset is linked to a leveraged vault (ERC1155 only)"
  vaultAddress: Account
  "Operator is logged for ERC1155 transfer events"
  operator: Account

  "Link to the transfer bundle this sits in"
  bundle: TransferBundle

  "Link to the transaction type this sits in"
  transactionType: TransactionType
}

type TransferBundle @entity {
  "Transaction Hash:Start Log Index:End Log Index:Bundle Name"
  id: ID!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Transaction!

  bundleName: String!
  transfers: [Transfer!] @derivedFrom(field: "bundle")
  
  "A logical grouping of transfer bundles into transaction types"
  transactionType: TransactionType
}

type TransactionType @entity {
  "Transaction Hash:Start Log Index:End Log Index:Transaction Type"
  id: ID!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Transaction!

  # TODO: this needs to have arbitrary properties
}

type Transaction @entity {
  "Transaction Hash"
  id: ID!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!

  _transfers: [Transfer!]
  _transferBundles: [TransferBundle!]
  _transactionTypes: [TransactionType!]

  # TODO: if we can't query via derivedFrom then these need to be manually appended
  transfers: [Transfer!] @derivedFrom(field: "transactionHash")
  transferBundles: [TransferBundle!] @derivedFrom(field: "transactionHash")
  transactionTypes: [TransactionType!] @derivedFrom(field: "transactionHash")
}

type Account @entity {
  "Address of Account"
  id: ID!

  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  isBurnAddress: Boolean!
  isSettlementReserve: Boolean!
  isNToken: Boolean!
  isVault: Boolean!
  isFeeReserve: Boolean!

  "All current balances linked to this account"
  balances: [Balance!] @derivedFrom(field: "account")
  "All historical asset transfers linked to this account"
  transfersFrom: [Transfer!] @derivedFrom(field: "from")
  transfersTo: [Transfer!] @derivedFrom(field: "to")
}