enum TokenType {
  Underlying,
  nToken,
  WrappedfCash,
  PrimeCash,
  PrimeDebt,
  fCash,
  VaultShare,
  VaultDebt,
  VaultCash,
  NOTE,
  Fiat
}

enum SystemAccount {
  None,
  ZeroAddress,
  FeeReserve,
  SettlementReserve,
  Vault,
  nToken,
  PrimeCash,
  PrimeDebt,
  Notional,
  NOTE,
  SecondaryIncentiveRewarder
}

enum TokenInterface {
  ERC20,
  ERC1155,
  "Used to designate off chain fiat currencies like USD, JPY, etc"
  FIAT
}

enum TransferType {
  Mint,
  Burn,
  Transfer
}

type Token @entity {
  """ID space varies by token type:
    - ERC20: token address
    - ERC1155: `emitter address:tokenId`
  """
  id: ID!

  firstUpdateBlockNumber: BigInt!
  firstUpdateTimestamp: Int!
  firstUpdateTransactionHash: Bytes

  lastUpdateBlockNumber: BigInt!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes

  tokenType: TokenType!
  tokenInterface: TokenInterface!
  "A link to the underlying token if this token is not underlying itself"
  underlying: Token
  "Set to the notional currency id if this token is listed on Notional"
  currencyId: Int
  
  name: String!
  symbol: String!
  decimals: Int!
  precision: BigInt!
  "Only updated for Notional entities"
  totalSupply: BigInt
  "Set to true for underlying tokens that have a transfer fee"
  hasTransferFee: Boolean!

  isfCashDebt: Boolean!
  "Maturities are only set for some token types"
  maturity: BigInt
  "Vault address is set for vault token types"
  vaultAddress: Bytes

  "Set to the ERC20 address or Notional Proxy for ERC1155 addresses"
  tokenAddress: Bytes!

  balanceOf: [Balance!] @derivedFrom(field: "token")
  transfers: [Transfer!] @derivedFrom(field: "token")
  oracles: [Oracle!] @derivedFrom(field: "quote")
  activeMarkets: ActiveMarket @derivedFrom(field: "underlying")
}

type Transfer @entity(immutable: true) {
  "Transaction Hash:Log Index"
  id: ID!
  blockNumber: BigInt!
  timestamp: Int!
  transactionHash: Transaction!
  logIndex: Int!

  from: Account!
  to: Account!
  "Operator is logged for ERC1155 transfer events"
  operator: Account
  "Categorizes the transfer as a mint, burn or transfer"
  transferType: TransferType!
  fromSystemAccount: SystemAccount!
  toSystemAccount: SystemAccount!

  value: BigInt!
  "Value of the transfer in underlying terms at the time of transfer"
  valueInUnderlying: BigInt

  "Link to the token entity for this transfer"
  token: Token!
  tokenType: TokenType!
  underlying: Token!
  "Only set for some transfer types"
  maturity: BigInt
}

type TransferBundle @entity(immutable: true) {
  "Transaction Hash:Start Log Index:End Log Index:Bundle Name"
  id: ID!
  blockNumber: BigInt!
  timestamp: Int!
  transactionHash: Transaction!

  bundleName: String!
  startLogIndex: Int!
  endLogIndex: Int!
  transfers: [Transfer!]!

  profitLossLineItems: [ProfitLossLineItem!] @derivedFrom(field: "bundle")
}

type ProfitLossLineItem @entity(immutable: true) {
  "Bundle ID:Index"
  id: ID!
  blockNumber: BigInt!
  timestamp: Int!
  transactionHash: Transaction!

  bundle: TransferBundle!
  balanceSnapshot: BalanceSnapshot!

  account: Account!
  tokenAmount: BigInt!
  token: Token!

  underlyingAmountRealized: BigInt!
  underlyingAmountSpot: BigInt!
  underlyingToken: Token!

  realizedPrice: BigInt!
  spotPrice: BigInt!
  impliedFixedRate: BigInt
  "Set to true for line items that do not materially change the balance at the end of the txn"
  isTransientLineItem: Boolean!

  "Set to a value that points to the token that generated an incentive payment"
  incentivizedToken: Token
}

type Transaction @entity(immutable: true) {
  "Transaction Hash"
  id: ID!
  blockNumber: BigInt!
  timestamp: Int!
  transactionHash: Bytes!

  _transfers: [Transfer!]!
  _transferBundles: [TransferBundle!]!
  "Internal index of the next index in _transfer to start scanning at"
  _nextStartIndex: Int!

  transfers: [Transfer!] @derivedFrom(field: "transactionHash")
  transferBundles: [TransferBundle!] @derivedFrom(field: "transactionHash")
}

type Account @entity {
  "Address of Account"
  id: ID!

  firstUpdateBlockNumber: BigInt!
  firstUpdateTimestamp: Int!
  firstUpdateTransactionHash: Bytes!

  lastUpdateBlockNumber: BigInt!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  systemAccountType: SystemAccount!

  allowPrimeBorrow: Boolean
  nextSettleTime: BigInt
  hasPortfolioAssetDebt: Boolean
  hasCashDebt: Boolean
  bitmapCurrencyId: Int

  "All current balances linked to this account"
  balances: [Balance!] @derivedFrom(field: "account")
  "All historical token transfers linked to this account"
  transfersFrom: [Transfer!] @derivedFrom(field: "from")
  transfersTo: [Transfer!] @derivedFrom(field: "to")
  profitLossLineItems: [ProfitLossLineItem!] @derivedFrom(field: "account")
}

### Exchange Rates ###

enum OracleType {
  Chainlink,
  fCashOracleRate,
  fCashSettlementRate,
  fCashToUnderlyingExchangeRate,
  fCashSpotRate,
  PrimeCashToUnderlyingOracleInterestRate,
  PrimeCashPremiumInterestRate,
  PrimeDebtPremiumInterestRate,
  PrimeCashExternalLendingInterestRate,
  PrimeCashToUnderlyingExchangeRate,
  PrimeCashToMoneyMarketExchangeRate,
  PrimeDebtToUnderlyingExchangeRate,
  PrimeDebtToMoneyMarketExchangeRate,
  MoneyMarketToUnderlyingExchangeRate
  VaultShareOracleRate,
  nTokenToUnderlyingExchangeRate,
  nTokenBlendedInterestRate,
  nTokenFeeRate,
  nTokenIncentiveRate,
  nTokenSecondaryIncentiveRate,
}

type nTokenFeeBuffer @entity {
  "Currency ID"
  id: ID!
  lastUpdateBlockNumber: BigInt!
  lastUpdateTimestamp: Int!

  "Circular buffer of transfers over the last 30 days, used for nToken fee APY calculation"
  feeTransfers: [Transfer!]!
  feeTransferAmount: [BigInt!]!
  "Current sum of the nToken fees over the last 30 days"
  last30DayNTokenFees: BigInt!
}

type OracleRegistry @entity {
  "ID is hardcoded to zero"
  id: ID!
  lastRefreshBlockNumber: BigInt!
  lastRefreshTimestamp: Int!

  chainlinkOracles: [Oracle!]!
  "Underlying tokens that have fCash listed"
  fCashEnabled: [Token!]!
  "Vault Addresses"
  listedVaults: [Bytes!]!
}

type Oracle @entity {
  "Base Token Id:Quote Token Id:Oracle Type"
  id: ID!

  lastUpdateBlockNumber: BigInt!
  lastUpdateTimestamp: Int!
  "Some oracles are updated via block handlers and do not have a txn hash for updates"
  lastUpdateTransaction: Transaction

  base: Token!
  quote: Token!
  decimals: Int!
  ratePrecision: BigInt!
  oracleAddress: Bytes!
  oracleType: OracleType!
  mustInvert: Boolean!
  latestRate: BigInt
  matured: Boolean!

  historicalRates: [ExchangeRate!] @derivedFrom(field: "oracle")
}

type ExchangeRate @entity(immutable: true) {
  "External Oracle ID:Block Number:Transaction Hash"
  id: ID!
  blockNumber: BigInt!
  timestamp: Int!
  transaction: Transaction
  oracle: Oracle!

  rate: BigInt!
  totalSupply: BigInt
}

### Configuration ###

type CurrencyConfiguration @entity {
  "Currency ID"
  id: ID!
  lastUpdateBlockNumber: BigInt!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  underlying: Token
  pCash: Token
  "Some currencies will not allow prime debt"
  pDebt: Token

  maxUnderlyingSupply: BigInt

  "Exchange Rate Parameters"
  collateralHaircut: Int
  debtBuffer: Int
  liquidationDiscount: Int

  "Prime Cash Parameters"
  primeCashRateOracleTimeWindowSeconds: Int
  primeCashHoldingsOracle: Bytes
  primeCashCurve: InterestRateCurve
  primeDebtAllowed: Boolean

  "Time window in seconds that the rate oracle will be averaged over"
  fCashRateOracleTimeWindowSeconds: Int
  "Share of the fees given to the protocol, denominated in percentage"
  fCashReserveFeeSharePercent: Int
  "Debt buffer specified in basis points"
  fCashDebtBufferBasisPoints: Int
  "fCash haircut specified in basis points"
  fCashHaircutBasisPoints: Int
  "Minimum oracle rate applied to fCash haircut"
  fCashMinOracleRate: Int
  "Maximum oracle rate applied to fCash buffer"
  fCashMaxOracleRate: Int
  "Maximum discount factor applied to fCash haircut"
  fCashMaxDiscountFactor: Int
  "Discount on fCash given to the liquidator in basis points"
  fCashLiquidationHaircutBasisPoints: Int
  "Discount on negative fCash given to the liquidator in basis points"
  fCashLiquidationDebtBufferBasisPoints: Int
  "Current set of interest rate curves for the fCash markets"
  fCashActiveCurves: [InterestRateCurve!]
  "Next set of interest rate curves for the fCash markets"
  fCashNextCurves: [InterestRateCurve!]

  "The minimum threshold of the reserve before they can be harvested"
  treasuryReserveBuffer: BigInt
  
  "Addresses of potential prime cash holdings"
  primeCashHoldings: [Bytes!]
  "Rebalancing targets"
  rebalancingTargets: [Int!]
  "Rebalancing cooldown"
  rebalancingCooldown: Int

  "Proportion of deposits that go into each corresponding market"
  depositShares: [Int!]
  "Maximum market proportion that the nToken will provide liquidity at"
  leverageThresholds: [Int!]
  "Market proportions used during market initialization"
  proportions: [Int!]
  deprecated_anchorRates: [Int!]

  "Residual purchase incentive in basis points"
  residualPurchaseIncentiveBasisPoints: Int
  "Seconds until residuals become available to purchase after market initialization"
  residualPurchaseTimeBufferSeconds: Int
  "Basis points of cash withholding for negative fCash"
  cashWithholdingBufferBasisPoints: Int
  "Percentage of the nToken PV that is used during free collateral"
  pvHaircutPercentage: Int
  "Discount on nToken PV given to liquidators"
  liquidationHaircutPercentage: Int
  "Maximum valuation deviation percentage for nToken minting"
  maxMintDeviationPercentage: Int

  incentives: Incentive @derivedFrom(field: "currencyConfiguration")
}

type InterestRateCurve @entity {
  "ID is the currency id:market index:true if current"
  id: ID!
  lastUpdateBlockNumber: BigInt!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  kinkUtilization1: Int!
  kinkUtilization2: Int!
  kinkRate1: Int!
  kinkRate2: Int!
  maxRate: Int!
  minFeeRate: Int!
  maxFeeRate: Int!
  feeRatePercent: Int!
}

type VaultConfiguration @entity {
  "ID is the address of the vault"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: BigInt!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  "Address of the strategy vault"
  vaultAddress: Bytes!
  "Strategy identifier for the vault"
  strategy: Bytes!
  "Name of the strategy vault"
  name: String!
  "Primary currency the vault borrows in"
  primaryBorrowCurrency: Token!
  "Minimum amount of primary currency that must be borrowed"
  minAccountBorrowSize: BigInt!
  "Minimum collateral ratio before liquidation"
  minCollateralRatioBasisPoints: Int!
  "Maximum collateral ratio that liquidation can reach"
  maxDeleverageCollateralRatioBasisPoints: Int!
  "Fee assessed on primary borrow paid to the nToken and protocol"
  feeRateBasisPoints: Int!
  "Share of fee paid to protocol reserve"
  reserveFeeSharePercent: Int!
  "Discount rate given to liquidators"
  liquidationRatePercent: Int!
  "Maximum market index for borrowing terms"
  maxBorrowMarketIndex: Int!
  "Secondary borrow currencies (if any)"
  secondaryBorrowCurrencies: [Token!]
  "Max required collateral ratio for vault accounts"
  maxRequiredAccountCollateralRatioBasisPoints: Int
  "Can the vault be entered"
  enabled: Boolean!
  "Allows positions to be rolled forward"
  allowRollPosition: Boolean!
  "Only the vault can enter"
  onlyVaultEntry: Boolean!
  "Only the vault can exit"
  onlyVaultExit: Boolean!
  "Only the vault can roll"
  onlyVaultRoll: Boolean!
  "Only the vault can liquidate"
  onlyVaultDeleverage: Boolean!
  "Only the vault can settle"
  onlyVaultSettle: Boolean!
  "fCash discounting is enabled on the vault"
  discountfCash: Boolean
  "Vault is allowed to re-enter Notional"
  allowsReentrancy: Boolean!
  "Deleveraging is disabled on this vault"
  deleverageDisabled: Boolean

  maxPrimaryBorrowCapacity: BigInt!
  totalUsedPrimaryBorrowCapacity: BigInt!

  maxSecondaryBorrowCapacity: [BigInt!]
  totalUsedSecondaryBorrowCapacity: [BigInt!]
  minAccountSecondaryBorrow: [BigInt!]
}
  # TODO: all of this information should sit on the account and total supply entities
  "All maturities of this strategy vault"
  # maturities: [LeveragedVaultMaturity!] @derivedFrom(field: "leveragedVault")

enum WhitelistedCapability {
  GlobalTransferOperator,
  AuthorizedCallbackContract
  SecondaryIncentiveRewarder,
  DetachedSecondaryIncentiveRewarder
}

type WhitelistedContract @entity {
  id: ID!
  lastUpdateBlockNumber: BigInt!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  capability: [WhitelistedCapability!]!
  name: String!

  # If this whitelisted contract is linked to a specific contract
  currency: CurrencyConfiguration
}

### Balances ###

type Balance @entity {
  "Account:Token ID"
  id: ID!
  "Link back to the token"
  token: Token!
  "Address of the account that holds this balance"
  account: Account!

  firstUpdateBlockNumber: BigInt!
  firstUpdateTimestamp: Int!
  firstUpdateTransactionHash: Bytes!

  lastUpdateBlockNumber: BigInt!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  
  current: BalanceSnapshot!
  snapshots: [BalanceSnapshot!] @derivedFrom(field: "balance")
}

type BalanceSnapshot @entity(immutable: true) {
  "Address of Account:ID of Token:Block Number"
  id: ID!
  blockNumber: BigInt!
  timestamp: Int!
  transaction: Transaction!

  "Link to previous snapshot, if it exists"
  previousSnapshot: BalanceSnapshot

  "Link to the balance entity for this token"
  balance: Balance!

  "Current balance of the token at this block"
  currentBalance: BigInt!
  "Balance before this snapshot"
  previousBalance: BigInt!

  "Adjusted cost basis at this snapshot for the token"
  adjustedCostBasis: BigInt!
  "Current profit and loss at the snapshot"
  currentProfitAndLossAtSnapshot: BigInt!
  "Total profit or loss at the snapshot since balance inception"
  totalProfitAndLossAtSnapshot: BigInt!
  "Portion of the PnL due to market movements in price"
  totalILAndFeesAtSnapshot: BigInt!
  "Portion of the PnL due to interest accrual"
  totalInterestAccrualAtSnapshot: BigInt!
  "Implied Fixed Rate for fCash balances"
  impliedFixedRate: BigInt
  
  "Cumulative balance used for internal PnL calculations"
  _accumulatedBalance: BigInt!
  "Cumulative realized cost for internal PnL calculations"
  _accumulatedCostRealized: BigInt!
  "Cumulative realized cost using adjusted cost basis for internal PnL calculations"
  _accumulatedCostAdjustedBasis: BigInt!

  profitLossLineItems: [ProfitLossLineItem!] @derivedFrom(field: "balanceSnapshot")
  "Snapshots of the secondary incentives"
  incentives: [IncentiveSnapshot!] @derivedFrom(field: "balanceSnapshot")
}

type IncentiveSnapshot @entity(immutable: true) {
  "Balance Snapshot ID:Reward Token"
  id: ID!
  blockNumber: BigInt!
  timestamp: Int!
  transaction: Transaction!

  "Link back to the balance snapshot for this secondary incentive"
  balanceSnapshot: BalanceSnapshot!

  "Reward token associated with this snapshot"
  rewardToken: Token!

  "Current account incentive debt for reward"
  currentIncentiveDebt: BigInt!
  "Previous account incentive debt for reward"
  previousIncentiveDebt: BigInt!

  "Total reward accrued over the lifetime of this balance"
  totalClaimed: BigInt!
  "Reward earnings adjusted for balance changes"
  adjustedClaimed: BigInt!
}

### Markets ###

type ActiveMarket @entity {
  "Currency ID"
  id: ID!
  lastUpdateBlockNumber: BigInt!
  lastUpdateTimestamp: Int!
  lastUpdateTransaction: Transaction
  
  underlying: Token!
  pCashMarket: PrimeCashMarket!
  fCashMarkets: [fCashMarket!]!
}

type PrimeCashMarket @entity {
  "Currency ID"
  id: ID!
  lastUpdateBlockNumber: BigInt!
  lastUpdateTimestamp: Int!
  lastUpdateTransaction: Transaction

  "Currency of this market"
  underlying: Token!
  "Prime Cash token for this market"
  primeCash: Token!
  "Prime Debt token for this market"
  primeDebt: Token

  current: PrimeCashMarketSnapshot!
  snapshots: [PrimeCashMarketSnapshot!] @derivedFrom(field: "market")
}

type PrimeCashMarketSnapshot @entity(immutable: true) {
  "Currency ID:Block Number:Transaction Hash"
  id: ID!
  blockNumber: BigInt!
  timestamp: Int!
  transaction: Transaction

  market: PrimeCashMarket!

  "Total Prime Cash Supply"
  totalPrimeCash: BigInt!
  "Total Prime Debt"
  totalPrimeDebt: BigInt!
  "Total underlying held by the contract"
  totalUnderlyingHeld: BigInt!
  "Total prime cash converted to underlying"
  totalPrimeCashInUnderlying: BigInt
  "Total prime debt converted to underlying"
  totalPrimeDebtInUnderlying: BigInt
  "Snapshot value of the supply scalar"
  supplyScalar: BigInt!
  "Snapshot value of the debt scalar"
  debtScalar: BigInt!
  "Snapshot value of the underlying scalar"
  underlyingScalar: BigInt!
  "Prime cash premium interest rate"
  supplyInterestRate: BigInt
  "Prime debt premium interest rate"
  debtInterestRate: BigInt
  "External lending interest rate"
  externalLendingRate: BigInt
}

type fCashMarket @entity {
  "Currency Id:Settlement Date:Maturity combination"
  id: ID!
  lastUpdateBlockNumber: BigInt!
  lastUpdateTimestamp: Int!
  lastUpdateTransaction: Transaction

  "Currency of this market"
  underlying: Token!
  "fCash token traded by this market"
  fCash: Token!
  "Date that fCash from this market will mature"
  maturity: Int!
  "Date that this market will settle"
  settlementDate: Int!
  "Market index"
  marketIndex: Int!
  "Length of market maturity in seconds"
  marketMaturityLengthSeconds: Int!

  current: fCashMarketSnapshot!
  snapshots: [fCashMarketSnapshot!] @derivedFrom(field: "market")
}

type fCashMarketSnapshot @entity(immutable: true) {
  "Market ID:Block Number"
  id: ID!
  blockNumber: BigInt!
  timestamp: Int!
  transaction: Transaction

  market: fCashMarket!

  "Total fCash available in the market"
  totalfCash: BigInt!
  "Total prime cash available in the market"
  totalPrimeCash: BigInt!
  "Total liquidity tokens available in the market"
  totalLiquidity: BigInt!
  "Last annualized interest rate the market traded at"
  lastImpliedRate: Int!
  "Oracle rate for the market, must be averaged in using previousTradeTime"
  oracleRate: Int!
  "Last time when a trade occurred on the market"
  previousTradeTime: Int!

  "Total prime cash converted to underlying in the market"
  totalPrimeCashInUnderlying: BigInt
  "Total fCash converted to present value in the market"
  totalfCashPresentValue: BigInt

  "Total fCash debt outstanding for the given fCash asset"
  totalfCashDebtOutstanding: BigInt!
  "Total fCash debt outstanding in present value terms for the given fCash asset"
  totalfCashDebtOutstandingPresentValue: BigInt
}

### Treasury ###

type Incentive @entity {
  "ID is the currency id"
  id: ID!
  lastUpdateBlockNumber: BigInt!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  currencyConfiguration: CurrencyConfiguration!

  "If set, a secondary incentive rewarder is set"
  secondaryIncentiveRewarder: Bytes

  "Annual incentive emission rate for NOTE"
  incentiveEmissionRate: BigInt
  "Current accumulated NOTE per nToken"
  accumulatedNOTEPerNToken: BigInt
  "Last accumulation time"
  lastAccumulatedTime: BigInt

  "Deprecated last supply change time value"
  deprecated_lastSupplyChangeTime: BigInt
  "Deprecated integral total supply value"
  deprecated_integralTotalSupply: BigInt
  "Snapshot of the incentive emission rate at migration"
  migrationEmissionRate: BigInt
  "Snapshot of the integral total supply at migration"
  finalIntegralTotalSupply: BigInt
  "Time when the currency was migrated"
  migrationTime: BigInt

  "Current secondary reward token set for this currency"
  currentSecondaryReward: Token
  "Total accumulated secondary reward per nToken for the current rewarder"
  accumulatedSecondaryRewardPerNToken: BigInt
  "Last accumulated time for the current rewarder"
  lastSecondaryAccumulatedTime: BigInt

  "Secondary incentive emission rate in INTERNAL_TOKEN_PRECISION"
  secondaryEmissionRate: BigInt
  "End time for the current secondary rewarder"
  secondaryRewardEndTime: BigInt
}

### Trading Module ###

enum DEX {
  _UNUSED,
  UNISWAP_V2,
  UNISWAP_V3,
  ZERO_EX,
  BALANCER_V2,
  CURVE,
  NOTIONAL_VAULT
}

enum TradeType {
  EXACT_IN_SINGLE,
  EXACT_OUT_SINGLE,
  EXACT_IN_BATCH,
  EXACT_OUT_BATCH
}

type TradingModulePermission @entity {
  id: ID!
  lastUpdateBlockNumber: BigInt!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  sender: Account!
  token: Token
  tokenAddress: Bytes!
  name: String!
  symbol: String!

  allowedDexes: [DEX!]!
  allowSell: Boolean!
  allowedTradeTypes: [TradeType!]!
}

type Reinvestment @entity {
  "Vault:TxnHash"
  id: ID!
  blockNumber: BigInt!
  timestamp: Int!
  transactionHash: Bytes!

  vault: VaultConfiguration!

  "Address of the token sold"
  rewardTokenSold: Token!
  "Amount of reward tokens sold"
  rewardAmountSold: BigInt!

  "Amount of LP tokens reinvested"
  tokensReinvested: BigInt!

  tokensPerVaultShare: BigInt
  "Value of the tokens reinvested"
  underlyingAmountRealized: BigInt
  "Vault Share Price after Reinvestment"
  vaultSharePrice: BigInt
}

# type ExternalLending @entity {
#   "Currency ID"
#   id: ID!

#   # snapshots
#   holdings: {
#     blockHash: BigInt
#     blockNumber: BigInt
#     timestamp: BigInt

#     holding: Token!

#     balanceOf: BigInt!
#     balanceOfUnderlying: BigInt!
#     storedBalanceOf: BigInt!
#     storedBalanceOfUnderlying: BigInt!
#     protocolLendingRevenueAllTime: BigInt
#     pCashLendingRevenueAllTime: BigInt

#     targetUtilization: BigInt!
#     currentUtilization: BigInt!
#     withdrawThreshold: number!
#     holdingAvailableToWithdraw: BigInt!
#   }
# }

# Staked NOTE