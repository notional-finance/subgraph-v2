enum ProposalStateEnum {
  PENDING
  CANCELLED
  QUEUED
  EXECUTED
}

enum VotingPowerSource {
  sNOTE,
  NOTE
}

type Proposal @entity {
  "Proposal's unique identifier"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  createdAt: Int!
  proposer: Delegate!
  votes: [Vote!]!
  history: [ProposalState!]
  targets: [Bytes!]!
  values: [BigInt!]!
  calldatas: [Bytes!]!
  startBlock: Int!
  endBlock: Int!
  isCancelled: Boolean
  isQueued: Boolean
  isExecuted: Boolean
}

type Vote @entity {
  "Address and proposal combined as the unique identifier"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  proposal: Proposal!
  delegate: Delegate!
  yesToProposal: Boolean!
  votingPower: BigInt!
}

type Delegate @entity {
  "Ethereum address"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  sNOTEVotingPower: BigInt!
  NOTEVotingPower: BigInt!
  totalVotingPower: BigInt!
  account: Account!

  delegatedNote: [NoteBalance!] @derivedFrom(field: "delegate")
  delegatedStakedNote: [StakedNoteBalance!] @derivedFrom(field: "delegate")
  votingPowerChange: [VotingPowerChange!] @derivedFrom(field: "delegate")
  votes: [Vote!] @derivedFrom(field: "delegate")
  proposals: [Proposal!] @derivedFrom(field: "proposer")
}

type VotingPowerChange @entity {
  "TokenAddress:TxnHash:LogIndex"
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!

  source: VotingPowerSource!
  delegate: Delegate!
  votingPowerBefore: BigInt!
  votingPowerAfter: BigInt!
}

type ProposalState @entity {
  id: ID!
  state: ProposalStateEnum!
  transactionHash: Bytes!
  lastUpdateTimestamp: Int!
}

type NoteBalance @entity {
  "Account address"
  id: ID!
  "Provides a link to a NOTE holder's Notional accounts (if they exist)"
  account: Account!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  delegate: Delegate
  noteBalance: BigInt!
  noteBalanceChanges: [NoteBalanceChange!]! @derivedFrom(field: "noteBalance")
}

type NoteBalanceChange @entity {
  "Account address:TransactionHash:LogIndex"
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!

  account: Account!
  noteBalance: NoteBalance!

  noteBalanceBefore: BigInt!
  noteBalanceAfter: BigInt!
  sender: Bytes!
  receiver: Bytes!
}

type StakedNoteBalance @entity {
  "Account address"
  id: ID!
  "Provides a link to a staker's Notional accounts (if they exist)"
  account: Account!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  delegate: Delegate

  "Current sNOTE balance of the account"
  sNOTEBalance: BigInt!
  "Total amount of ETH/WETH used to join the pool"
  ethAmountJoined: BigInt!
  "Total amount of NOTE used to join the pool"
  noteAmountJoined: BigInt!

  "Total amount of ethRedeemed from the pool"
  ethAmountRedeemed: BigInt!
  "Total amount of noteRedeemed from the pool"
  noteAmountRedeemed: BigInt!

  currentCoolDown: StakedNoteCoolDown
  coolDowns: [StakedNoteCoolDown!] @derivedFrom(field: "stakedNoteBalance")
  stakedNoteChanges: [StakedNoteChange!]! @derivedFrom(field: "stakedNoteBalance")
}

type StakedNoteCoolDown @entity {
  id: ID!
  startedBlockHash: Bytes!
  startedBlockNumber: Int!
  startedTimestamp: Int!
  startedTransactionHash: Bytes!

  endedBlockHash: Bytes
  endedBlockNumber: Int
  endedTimestamp: Int
  endedTransactionHash: Bytes

  stakedNoteBalance: StakedNoteBalance!
  userEndedCoolDown: Boolean
  redeemWindowBegin: Int!
  redeemWindowEnd: Int!
}

enum sNOTEChangeType {
  Transfer,
  Stake,
  Unstake
}

type StakedNoteChange @entity {
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!

  account: Account!
  stakedNoteBalance: StakedNoteBalance!

  sNOTEChangeType: sNOTEChangeType!
  sNOTEAmountBefore: BigInt!
  sNOTEAmountAfter: BigInt!
  ethAmountChange: BigInt!
  noteAmountChange: BigInt!
  bptAmountChange: BigInt!

  sender: Bytes
  receiver: Bytes
}

type StakedNotePool @entity {
  "Staked NOTE address"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  totalBPTTokens: BigInt!
  totalSupply: BigInt!
  bptPerSNOTE: BigInt!
}

type StakedNoteInvestment @entity {
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  "The treasury manager who executed the investment"
  manager: TreasuryManager!

  bptPerSNOTEBefore: BigInt!
  bptPerSNOTEAfter: BigInt!
  totalETHInvested: BigInt!
  totalNOTEInvested: BigInt!
  totalSNOTESupply: BigInt!
}

type Treasury @entity {
  "ID hardcoded to zero"
  id: ID!
  contractAddress: Bytes!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  activeManager: TreasuryManager
  investmentCoolDownInSeconds: BigInt
  NOTEPurchaseLimit: BigInt
  tradingLimits: [TreasuryManagerTradingLimit!] @derivedFrom(field: "treasury")

  "A list of all treasury managers"
  managers: [TreasuryManager!] @derivedFrom(field: "treasury")
}

type TreasuryManager @entity {
  "ID is the manager's ethereum address"
  id: ID!
  startedBlockHash: Bytes!
  startedBlockNumber: Int!
  startedTimestamp: Int!
  startedTransactionHash: Bytes!

  endedBlockHash: Bytes!
  endedBlockNumber: Int!
  endedTimestamp: Int!
  endedTransactionHash: Bytes!

  "Set to true for the manager who is currently active"
  isActiveManager: Boolean!
  treasury: Treasury!
  sNOTEInvestments: [StakedNoteInvestment!] @derivedFrom(field: "manager")
  tokenTrades: [TreasuryTokenTrade!] @derivedFrom(field: "manager")
}

type TreasuryManagerTradingLimit @entity {
  "ID is the token address"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  treasury: Treasury!
  tokenAddress: Bytes!
  symbol: String!
  name: String!
  oracle: Bytes
  slippageLimit: BigInt
}

type TreasuryTokenTrade @entity {
  "ID is the 0x order hash"
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!

  manager: TreasuryManager!
  "Taker that filled the order"
  takerAddress: Bytes!
  "Token that the treasury sold"
  makerAsset: TreasuryManagerTradingLimit!
  "Token that the taker sent back to the treasury"
  takerAsset: Bytes!
  takerAssetSymbol: String
  takerAssetName: String
  takerAssetDecimals: Int

  makerAssetFilledAmount: BigInt!
  takerAssetFilledAmount: BigInt!
  oraclePrice: BigInt
  oracleDecimals: Int
}