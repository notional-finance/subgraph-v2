enum AssetType {
  fCash
  LiquidityToken_3Month
  LiquidityToken_6Month
  LiquidityToken_1Year
  LiquidityToken_2Year
  LiquidityToken_5Year
  LiquidityToken_10Year
  LiquidityToken_20Year
}

type Account @entity {
  "Account address"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  "Timestamp of the next time that the account will require settlement"
  nextSettleTime: BigInt!
  "True if the account's portfolio has debt assets"
  hasPortfolioAssetDebt: Boolean!
  "True if the account's cash balances have debt, may be temporarily inconsistent after a SettleCashEvent"
  hasCashDebt: Boolean!

  "Currency id of an asset bitmap, if set"
  assetBitmapCurrency: Currency
  "Account's balances of both cash and nTokens"
  balances: [Balance!]!
  "Account's portfolio assets"
  portfolio: [Asset!]!

  "A link to the nToken object if this is an nToken"
  nToken: nToken

  tradeHistory: [Trade!] @derivedFrom(field: "account")
  balanceChanges: [BalanceChange!] @derivedFrom(field: "account")
  assetChanges: [AssetChange!] @derivedFrom(field: "account")
  nTokenChanges: [nTokenChange!] @derivedFrom(field: "account")
  leveragedVaults: [LeveragedVaultAccount!] @derivedFrom(field: "account")

  stakedNoteBalance: StakedNoteBalance @derivedFrom(field: "account")
  stakedNoteChanges: [StakedNoteChange!] @derivedFrom(field: "account")
}

type Balance @entity {
  "Account Address:Currency ID combination"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  "Reference to currency that this balance represents"
  currency: Currency!

  "Cash balance denominated in asset cash terms"
  assetCashBalance: BigInt!
  "nToken balance of this currency"
  nTokenBalance: BigInt!
  "Last time token incentives were claimed on this balance"
  lastClaimTime: Int!
  "Last stored integral total supply amount, used to calculate incentives in the original method"
  lastClaimIntegralSupply: BigInt
  "Accumulator for incentive calculation"
  accountIncentiveDebt: BigInt
  "True if the account has migrated to the new incentive scheme"
  didMigrateIncentives: Boolean
}

type Asset @entity {
  "Account:CurrencyId:AssetType:Maturity"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  "Reference to currency that this balance represents"
  currency: Currency!
  "Timestamp when fCash matures, if liquidity token this will still refer to fCash maturity date"
  maturity: BigInt!
  "Date when assets will be settled, quarterly for liquidity tokens and at maturity for fCash"
  settlementDate: BigInt!
  "Asset type"
  assetType: AssetType!
  "Notional amount"
  notional: BigInt!
}

type Market @entity {
  "Currency Id:Settlement Date:Maturity combination"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!

  "Currency of this market"
  currency: Currency!
  "Date that fCash from this market will mature"
  maturity: Int!
  "Date that this market will settle"
  settlementDate: Int!
  "Market index"
  marketIndex: Int!
  "Length of market maturity in seconds"
  marketMaturityLengthSeconds: Int!

  "Total fCash available in the market"
  totalfCash: BigInt!
  "Total asset cash available in the market"
  totalAssetCash: BigInt!
  "Total liquidity tokens available in the market"
  totalLiquidity: BigInt!
  "Last annualized interest rate the market traded at"
  lastImpliedRate: Int!
  "Oracle rate for the market, must be averaged in using previousTradeTime"
  oracleRate: Int!
  "Last time when a trade occurred on the market"
  previousTradeTime: Int!

  historicalData: [MarketHistoricalData!] @derivedFrom(field: "market")
}

